{"ast":null,"code":"'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n  // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n  // `Function#prototype` is non-writable and non-configurable so can never be modified.\n  if (property === 'length' || property === 'prototype') {\n    return;\n  }\n\n  // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n  if (property === 'arguments' || property === 'caller') {\n    return;\n  }\n  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n    return;\n  }\n  Object.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n  return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);\n};\nconst changePrototype = (to, from) => {\n  const fromPrototype = Object.getPrototypeOf(from);\n  if (fromPrototype === Object.getPrototypeOf(to)) {\n    return;\n  }\n  Object.setPrototypeOf(to, fromPrototype);\n};\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n  const withName = name === '' ? '' : `with ${name.trim()}() `;\n  const newToString = wrappedToString.bind(null, withName, from.toString());\n  // Ensure `to.toString.toString` is non-enumerable and has the same `same`\n  Object.defineProperty(newToString, 'name', toStringName);\n  Object.defineProperty(to, 'toString', {\n    ...toStringDescriptor,\n    value: newToString\n  });\n};\nconst mimicFn = (to, from, {\n  ignoreNonConfigurable = false\n} = {}) => {\n  const {\n    name\n  } = to;\n  for (const property of Reflect.ownKeys(from)) {\n    copyProperty(to, from, property, ignoreNonConfigurable);\n  }\n  changePrototype(to, from);\n  changeToString(to, from, name);\n  return to;\n};\nmodule.exports = mimicFn;","map":{"version":3,"names":["copyProperty","to","from","property","ignoreNonConfigurable","toDescriptor","Object","getOwnPropertyDescriptor","fromDescriptor","canCopyProperty","defineProperty","undefined","configurable","writable","enumerable","value","changePrototype","fromPrototype","getPrototypeOf","setPrototypeOf","wrappedToString","withName","fromBody","toStringDescriptor","Function","prototype","toStringName","toString","changeToString","name","trim","newToString","bind","mimicFn","Reflect","ownKeys","module","exports"],"sources":["D:/Own_Create/calendar/node_modules/mem/node_modules/mimic-fn/index.js"],"sourcesContent":["'use strict';\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nconst mimicFn = (to, from, {ignoreNonConfigurable = false} = {}) => {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}